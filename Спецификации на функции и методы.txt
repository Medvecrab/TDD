Класс Field (игровое поле)
Конструктор Field (size) - создаёт пустое поле.
fill_default - добавляет на поле подписи, обозначает клетки, на которые можно ставить корабли. Может использоваться для сброса состояния поля.
place_ship (int size, int direction, int row, int column) - добавляет на поле корабль длиной size, в направлении direction (1 - вверх, 2 - вправо, 3 - вниз, 4 - влево), первая клетка корабля
находится по координатам (row, column). При попытке поставить корабль так, что он окажется вне поля, будет выводиться сообщение и возвращаться BOUNDARY_ERROR (= -2)
При попытке поставить корабль поверх существующего будет возвращаться COLLISION_ERROR (= -3)
При ошибке входных данных будет возвращаться INPUT_ERROR (= -1)
shoot (int row, int column) - производит выстрел по координатам (row, column) - если там был корабль, возвращает 1, если было пусто - 0. при неправильных координатах возвращает INPUT_ERROR
print_field и print_enemy_field - функции выводят поле игрока и поле противника (компьютера). Поле противника изначально скрывается. Тестов с помощью CppUnitTestFramework я делать не буду,
потому что не знаю, как нормально отлавливать данные в выходном формате/printf 
check_win - функция, проверяющая, остались ли на игровом поле клетки живых кораблей. Если да - выводит 0, если все подбиты - выводит 1.
С этого момента правила решено упростить - корабли МОЖНО расставлять рядом друг с другом -> не нужно расставлять . вокруг подбитого корабля.
Так же не ведётся учёт "оставшихся кораблей", только учёт "оставшихся клеток кораблей".

Теперь буду писать класс Game, который будет осуществлять запуск и ведение игры, а так же поведение компьютера.
метод main_menu() - выводит главное меню, в котором предлагается выбрать количество кораблей для игрока и для компьютера, потом их расставить, и потом начать игру.
Если попробовать расставить корабли без выбора их количества будет выдана ошибка NO_SHIPS. Такая же ошибка будет, если без расстановки попробовать начать игру.
Компьютер расставляет свои корабли сразу после того, как это сделает игрок
Тестирование конкретно main_menu особо не имеет смысла, потому что параметры в этот метод не передаются, и все ошибки будут создавать методы, работающие внутри.
Метод play_game состоит из последовательных ходов игрока и бота, до победы одного из них. В конце игроку предлагается сыграть ещё раз