Класс Field (игровое поле)
Конструктор Field (size) - создаёт пустое поле.
fill_default - добавляет на поле подписи, обозначает клетки, на которые можно ставить корабли. Может использоваться для сброса состояния поля.
place_ship (int size, int direction, int row, int column) - добавляет на поле корабль длиной size, в направлении direction (1 - вверх, 2 - вправо, 3 - вниз, 4 - влево), первая клетка корабля
находится по координатам (row, column). При попытке поставить корабль так, что он окажется вне поля, будет выводиться сообщение и возвращаться BOUNDARY_ERROR (= -2)
При попытке поставить корабль поверх существующего будет возвращаться COLLISION_ERROR (= -3)
При ошибке входных данных будет возвращаться INPUT_ERROR (= -1)
shoot (int row, int column) - производит выстрел по координатам (row, column) - если там был корабль, возвращает 1, если было пусто - 0. при неправильных координатах возвращает INPUT_ERROR
print_field и print_enemy_field - функции выводят поле игрока и поле противника (компьютера). Поле противника изначально скрывается. Тестов с помощью CppUnitTestFramework я делать не буду,
потому что не знаю, как нормально отлавливать данные в выходном формате/printf 
check_win - функция, проверяющая, остались ли на игровом поле клетки живых кораблей. Если да - выводит 0, если все подбиты - выводит 1.
С этого момента правила решено упростить - корабли МОЖНО расставлять рядом друг с другом -> не нужно расставлять . вокруг подбитого корабля.
Так же не ведётся учёт "оставшихся кораблей", только учёт "оставшихся клеток кораблей".